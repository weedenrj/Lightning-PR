name: Release PR Summary

on:
  pull_request:
    types: [opened, synchronize]
    branches:
      - main
  issue_comment:
    types: [created]

jobs:
  analyze-release:
    if: |
      (github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'main' && github.event.pull_request.head.ref == 'develop') ||
      (github.event_name == 'issue_comment' && github.event.issue.pull_request && contains(github.event.comment.body, '/update'))
    runs-on: ubuntu-latest
    
    permissions:
      pull-requests: write
      contents: read
      actions: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Scan for Linear issues and update PR description
        id: analyze
        uses: actions/github-script@v7
        env:
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
        with:
          script: |
            const { execSync } = require('child_process');
            
            const prNumber = context.issue.number || context.payload.pull_request.number;
            
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            if (pr.data.base.ref !== 'main' || pr.data.head.ref !== 'develop') {
              console.log(`Skipping: This workflow only runs for develop‚Üímain PRs. Current PR is ${pr.data.head.ref}‚Üí${pr.data.base.ref}`);
              return;
            }
            
            const linearIssues = new Set();
            
            const commitRange = 'origin/main..origin/develop';
            const commits = execSync(`git log ${commitRange} --format="%H|%s|%b"`, { encoding: 'utf8' })
              .trim()
              .split('\n')
              .filter(line => line.length > 0);
            
            console.log(`Found ${commits.length} commits to analyze`);
            
            commits.forEach(commitLine => {
              const parts = commitLine.split('|', 3);
              const subject = parts[1] || '';
              const body = parts[2] || '';
              const fullMessage = `${subject}\n${body}`;
              
              const valMatches = fullMessage.match(/\b(VAL-\d+)\b/gi);
              if (valMatches) {
                valMatches.forEach(match => linearIssues.add(match.toUpperCase()));
              }
            });
            
            const prTitle = pr.data.title || '';
            const prBody = pr.data.body || '';
            const branchName = pr.data.head.ref || '';
            
            const prTitleMatches = prTitle.match(/\b(VAL-\d+)\b/gi);
            if (prTitleMatches) {
              prTitleMatches.forEach(match => linearIssues.add(match.toUpperCase()));
            }
            
            const prBodyMatches = prBody.match(/\b(VAL-\d+)\b/gi);
            if (prBodyMatches) {
              prBodyMatches.forEach(match => linearIssues.add(match.toUpperCase()));
            }
            
            const branchMatches = branchName.match(/\b(VAL-\d+)\b/gi);
            if (branchMatches) {
              branchMatches.forEach(match => linearIssues.add(match.toUpperCase()));
            }
            
            console.log(`Found ${linearIssues.size} unique Linear issues: ${Array.from(linearIssues).join(', ')}`);
            
            const issueDetails = new Map();
            
            for (const issueId of Array.from(linearIssues).sort()) {
              try {
                const query = `
                  query {
                    issue(id: "${issueId}") {
                      identifier
                      title
                    }
                  }
                `;
                
                const response = await fetch('https://api.linear.app/graphql', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': process.env.LINEAR_API_KEY
                  },
                  body: JSON.stringify({ query })
                });
                
                const data = await response.json();
                
                if (data.data && data.data.issue) {
                  issueDetails.set(issueId, data.data.issue.title);
                  console.log(`Fetched ${issueId}: ${data.data.issue.title}`);
                } else {
                  issueDetails.set(issueId, '(Unable to fetch title)');
                  console.log(`Failed to fetch ${issueId}: ${JSON.stringify(data)}`);
                  if (data.errors) {
                    console.error(`Linear API errors for ${issueId}:`, JSON.stringify(data.errors));
                  }
                }
              } catch (error) {
                issueDetails.set(issueId, '(Unable to fetch title)');
                console.error(`Error fetching ${issueId}:`, error);
              }
            }
            
            const currentDate = new Date().toLocaleDateString('en-US', { 
              month: 'short', 
              day: 'numeric', 
              year: 'numeric' 
            });
            
            let updatedBody = prBody.replace(/# üöÄ \[Date\] Production Release/g, `# üöÄ ${currentDate} Production Release`);
            
            const releaseNotesBullets = Array.from(linearIssues)
              .sort()
              .map(issueId => `- ${issueDetails.get(issueId)}`)
              .join('\n');
            
            const linearIssuesBullets = Array.from(linearIssues)
              .sort()
              .map(issueId => `- closes ${issueId}`)
              .join('\n');
            
            const beforeReleaseNotes = updatedBody;
            updatedBody = updatedBody.replace(
              /(## Release Notes\s*\n+)([\s\S]*?)(\n+## Linear Issues)/,
              `$1${releaseNotesBullets || '- No Linear issues found'}$3`
            );
            if (updatedBody === beforeReleaseNotes) {
              console.warn('Warning: Could not find "## Release Notes" section in PR body');
            }
            
            const beforeLinearIssues = updatedBody;
            updatedBody = updatedBody.replace(
              /(## Linear Issues\s*\n+)([\s\S]*?)(\n+## Pre-Release Checklist)/,
              `$1${linearIssuesBullets || '- No Linear issues found'}$3`
            );
            if (updatedBody === beforeLinearIssues) {
              console.warn('Warning: Could not find "## Linear Issues" section in PR body');
            }
            
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              body: updatedBody
            });
            
            console.log('Updated PR description with Linear issues and current date');

  notify-failure:
    if: failure()
    needs: analyze-release
    runs-on: ubuntu-latest
    
    permissions:
      pull-requests: write
      contents: read
    
    steps:
      - name: Post failure comment
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.issue.number || context.payload.pull_request.number;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: '## ‚ö†Ô∏è Release Summary Generation Failed\n\n' +
                'The automated release summary could not be generated.\n\n' +
                '**Error**: Failed during commit analysis step\n\n' +
                '**Next steps**: Check the [workflow logs](' + context.payload.repository.html_url + '/actions/runs/' + context.runId + ') for details.'
            });
